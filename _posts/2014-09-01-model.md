---
layout: post
unique_identifier:
 - 'http:/example.jp/bookid_in_url'
 - 'BookID'
 - 'URL'
title: 'モデル'
creator: '五十嵐邦明'
date: '2014-09-01'
categories:
---

# モデル

この章ではデータの長期保存と、その際に使うモデルについて説明します。

説明に使うアプリは前の章でつくったものを引き続き使います。

## データの永続化

コード中で変数に代入したデータは、変数の有効範囲（スコープと言います）が終わると消えてしまいます。次のコードを見てみましょう。

```ruby
def print_hello_world
  x = "Hello world!"
  puts x
end
```

変数xの有効範囲（スコープ）は、そのメソッドの中だけです（このような変数をローカル変数と呼びます）。この場合、メソッド`print_hello_world`の実行が終わると変数xと、それが指すオブジェクトは消えてしまいます。

別の種類の変数として、前の章でも出てきた@bookのようなインスタンス変数（名前が@はじまりの変数）があります。インスタンス変数は、インスタンス（オブジェクト）がなくなると一緒に消えます。Railsの場合は、1つのリクエスト内が有効範囲だと考えることができます。ここではおおまかに、ブラウザであるページを表示することが1回のリクエストだと考えて差し支えありません。別のページを表示したり、リロードを行ったりすると、新しい別のリクエストになります。インスタンス変数に代入すると、コントローラからビューまで使うことができますが、その後なくなります。

それでも、つくったRailsアプリでは別のリクエストでも情報が見れますよね？　新規入力画面で情報を入力して一度登録してしまえば、その後ブラウザから何回アクセスしても、たとえば一覧画面で何回リロードしても表示されます。

つまり、複数のリクエストに渡ってデータが保存されていることになります。これはインスタンス変数では実現できません。データがずっと残っているのは「データを保存する」仕事をしている「何かの仕組み」があるからなのです。

その仕組みがこの章の主役、モデル（Model）です。

この章はモデルについて説明します。また、この章では前の章につづいてCRUDのcreateの部分を題材に説明します。

![この章の題材](assets/model/figures/crud-create.png)

処理の流れはこの部分です。前の章でコントローラの処理の途中まで説明したので、そのつづきになります。

![処理の流れ](assets/model/figures/create_flow_controller.png)

コードではこの部分です。

app/controllers/books_controller.rb

```ruby
def create
  @book = Book.new(book_params) # ⬅️1. リクエストのパラメータを使って本のデータを作る
  respond_to do |format|
    if @book.save # ⬅️2. 本のデータを保存する
      # ⬅️3a. 成功したらshow画面へ
      format.html { redirect_to @book, notice: 'Book was successfully created.' }
      format.json { render :show, status: :created, location: @book }
    else
      # ⬅️3b. 保存失敗したらnew画面へ（元の画面）
      format.html { render :new }
      format.json { render json: @book.errors, status: :unprocessable_entity }
    end
  end
end
```

このコードの中で、モデルを利用しているところはこの部分です。

```ruby
def create
  @book = Book.new(book_params) # ⬅️BookクラスはModelという種族に属する
  respond_to do |format|
    if @book.save # ⬅️ここで保存
      format.html { redirect_to @book, notice: 'Book was successfully created.' }
      format.json { render :show, status: :created, location: @book }
    else
      format.html { render :new }
      format.json { render json: @book.errors, status: :unprocessable_entity }
    end
  end
end
```

では、モデルの仕事について見ていきましょう。

## モデルの基本的な使い方　その1　保存

モデルを使うとデータを保存することができます。以下の手順で保存できます。

```ruby
book = Book.new(title: "RubyとRailsの学習ガイド", memo: "Rails関連技術地図とそれらの学習資料の紹介")
book.save!
```

Book.newでBookモデルオブジェクトを作ります。このとき、タイトルとメモの情報を渡すことができます。

なお、モデル名（モデルのクラス名）は英語の単数形、大文字始まりにするルールがあります。ここではBookがモデル名で、単数形で大文字始まりになっています。また、すべて小文字のbookは変数名です。1つのBookモデルオブジェクトが代入されるため単数形を使います。

Bookモデルオブジェクトのsave!メソッドを呼び出すと保存できます。保存するメソッドはいくつかあり、他にもsave,create!, createメソッドなどがあります。saveとsave!の違いは、なんらかの理由で保存できなかったときの動作です。保存に失敗したとき、saveメソッドはfalseを返し、save!メソッドでは例外が投げられます。createとcreate!の違いも同様です。

## モデルの基本的な使い方　その2　読み込み

さきほど保存したデータを読み込んでみましょう。

```ruby
books = Book.all.to_a
```

Book.allで保存されているBookモデルの全データを取得できます。以前に説明した一覧画面（indexアクション）でこのメソッドが使われています。

`Book.all.to_a`でArray（配列）にBookオブジェクトが詰まって返ってきます。`to_a`はArrayオブジェクトへ変換するメソッドです。代入される変数名は小文字のbooksで、複数のBookオブジェクトが代入されるので複数形を使います。

## モデルの基本的な使い方　その3　検索

```ruby
book = Book.where(title: "RubyとRailsの学習ガイド").first
book.title #=> "RubyとRailsの学習ガイド"
book.memo #=> "Rails関連技術地図とそれらの学習資料の紹介"
```

whereメソッドを使うと検索ができます。タイトルが"ハチミツとクローバー"であるBookオブジェクトが返ります。検索結果が複数になることもあるので、firstメソッドで最初の1つを取得しています。取得するオブジェクトは1つなので、それを代入する変数名bookは単数形になっています。

取得したBookオブジェクトはtitleメソッドでタイトルを、memoメソッドでメモをそれぞれ返します。

## 実習 : rails consoleでモデルを使う

Railsには "rails console" という、1行ずつ入力したコードを実行する機能があります。Rubyが持っているirbをつかって、1行ずつ入力したRailsのコードを実行することができます。つくったアプリがあるフォルダへ移動して、rails consoleを使ってみましょう。ターミナルで`rails c`と実行してみてください。cはconsoleの頭文字です。メッセージ中"in process 53813"の数字は実行するたびに異なります。

```console
cd books_app
rails c
```

TODO: 最新Railsバージョンで置き換え

```console
$ rails c
Running via Spring preloader in process 16386
Loading development environment (Rails 6.0.0)
irb(main):001:0> exit
```

rails consoleで以下のコードを実行してみてください。

```ruby
book = Book.new(title: "some title", memo: "some memo") # モデルオブジェクト作成
book.save! # 保存
Book.last # 上で保存したデータの表示
```

前に出てきたwhereでの検索も試してみてください。rails consoleを終了するときはexitと打ってください。

また、rails consoleで保存したデータは、ブラウザで保存したデータと同じ場所に格納され、同じように取り扱われます。ここで保存したデータはブラウザからも見ることができます。

```ruby
rails s
```

ブラウザで http://localhost:3000/books へアクセスして、rails consoleから保存したデータが表示されることを確認してみましょう。

## モデルの仕組み

次は、モデルのコードを見てみましょう。モデルのコードはapp/models/フォルダ以下にあります。Bookモデルのコード`app/models/book.rb`を見てみましょう。

```ruby
class Book < ApplicationRecord
end
```

Bookモデルにはコードがほとんどありません。

では、saveやallといったメソッドが使えるのはなぜでしょうか？　また、titleやmemoの情報があることをどこで知るのでしょうか？

### 問: saveやallといったメソッドが使えるのはなぜでしょうか？

答えは `ApplicationRecord` クラスを継承しているからです。 `ApplicationRecord` クラス（およびさらに親のクラス）がモデルの仕事に必要な機能を持っています。それを継承しているBookクラスも同じ機能を持ちます。

### 問: titleやmemoといった要素があることをどこで知るのでしょうか？

答えは「データベースから情報を得る」です。

ApplicationRecordはデータベースから情報を得て、Bookモデルにtitle、memoという要素があることを知っています。その情報を使って、book.titleやbook.memoといったメソッドを提供します。

では、データベースとは何でしょうか？

### データベース（DB）とは？

DBとは、データを保存したり、読み出したり、検索したりするために特化したプログラムです。

モデルはDBを便利につかうための仕組みでもあります。DBは高機能で堅牢でかつ高速です。しかし、DBへアクセスするには一般に専用の言語（SQLと言います）を用いることが多く、Rubyのコードからは扱いづらいという問題があります。モデルはRubyでDBを容易に扱うことができる機能も提供します。

![DBとは？](assets/model/figures/db.png)

では、DBはいつのまに作られたのでしょう？

## DBはいつ作られたのか？

books appを作る一連のコマンドを入力した際に、以下のコマンドでDBを作成していました。

```console
rails g scaffold book title:string memo:text
rails db:migrate
```

scaffoldコマンドはいろいろなものを作りますが、その1つとしてDBの設計書「マイグレーション（migration）ファイル」をつくります。

```console
rails g scaffold book title:string memo:text
...
invoke  active_record
create    db/migrate/20191212002328_create_books.rb
create    app/models/book.rb
...
```

そしてrails db:migrateコマンドを実行すると、さきほど作られた設計書を使ってDBを作ります。

設計書であるmigrationファイルから順に見ていきましょう。

## マイグレーション（migration）ファイル

DBの設計書をマイグレーションファイルと呼びます。マイグレーションファイルもRails（Ruby）のコードで書かれています。

では、マイグレーションファイルを見てみましょう。ファイル名には"20191212002328"と実行した日付から作られた数字が入っているので、rails gコマンドを実行するごとに異なるファイル名になります。

`db/migrate/20191212002328_create_books..rb`

```ruby
class CreateBooks < ActiveRecord::Migration[6.0]
  def change
    create_table :books do |t|
      t.string :title
      t.text :memo

      t.timestamps
    end
  end
end
```

1行目 `ActiveRecord::Migration[6.0]` の末尾にある数字はRailsのバージョンを表します。Rails6.0.xではこのように6.0となります。

3行目 `create_table :books` でbooksという名前のテーブルを作ります。DBはテーブルという単位でデータを管理します。ここでは、本に関するデータを保存するためにbooksという名前のテーブルを作っています。テーブル名はモデル名の複数形にするというルールがあります。

4行目 `t.string :title` と5行目 `t.text :memo` はテーブルの要素を作成しています。これでbooksテーブルにはtitleという要素と、memoという要素を持つことになります。この要素のことをDBの用語でカラムといいます。stringはデータの型の1つです。文字列を格納します。textもデータの型の1つで、stringよりも長い文字列を格納できる型です。

それに続く `t.timestamps` は、`created_at`（作成日時）、`updated_at`（更新日時）を記録するカラムを作ります。

DBのテーブルはExcelをイメージすると分かり易いです。DBへデータを格納していくことは、title、memoといった列があるExcelのシートに1行ずつデータを格納していくイメージです。

![booksテーブルのイメージ](assets/model/figures/migration_excel.png)

ところで、 `t.string :title` や `t.text :memo` に見覚えがありませんか？

これらはscaffoldのコマンドで書かれていました。実は、scaffoldで指定していたのはテーブル名とカラム、データの型でした。scaffoldでは、booksテーブルにstring型であるtitleカラムとtext型であるmemoカラムを作成する、という指示を与えていたことになります。

ここまでで、scaffoldはDB設計書（migration）を作ることを説明しました。

![scaffold は migration を作る](assets/model/figures/migration_created.png)

では、migrationから実際にDBを作るにはどうすれば良いでしょうか？

![migrationからDBを作るには？](assets/model/figures/migration_how_to_make_db.png)

DB設計書（migration）からDBテーブルを作るのが `rails db:migrate` コマンドです。 `rails db:migrate`コマンドを実行すると、/db/migrateフォルダにあるマイグレーションファイルを実行してDBテーブルを作ります。

![rails db migrate コマンドがmigrationからDBを作る](assets/model/figures/migration_rails_db_migrate.png)

## 保存したあとの処理

それでは、コントローラでの処理の話に戻りましょう。`@book.save` に関する動作を見て行きます。次のプログラム「2.本のデータを保存する」の部分です。

app/controllers/books_controller.rb

```ruby
@book = Book.new(book_params) # 1. リクエストのパラメータを使って本のデータを作る

respond_to do |format|
  if @book.save # 2. 本のデータを保存する
    # 3a. 成功したらshow画面へ
    format.html { redirect_to @book, notice: 'Book was successfully created.' }
    format.json { render :show, status: :created, location: @book }
  else
    # 3b. 失敗したらnew画面へ（前の画面）
    format.html { render :new }
    format.json { render json: @book.errors, status: :unprocessable_entity }
  end
end
```

長いので、着目するところだけ残して短くしましょう。まず、`respond_to do |format|`はリクエストされたレスポンスの形式によって分岐させる文です。ブラウザでnew画面に内容を入力してリクエストを飛ばした場合は`format.html`が選ばれます。もう一方のjsonはデータ形式の1つで、たとえばスマートフォンアプリなど、ブラウザ以外で表示させるときによく利用されます。formatに関する処理を除くと次のようになります。

```ruby
@book = Book.new(book_params)
if @book.save
  redirect_to @book, notice: 'Book was successfully created.'
else
  render :new
end
```

`@book.save`は成功するとtrue、失敗するとfalseを返します。 `@book.save`の前に書いてあるifは分岐させる命令です。ifのあとに書かれた処理（ここでは`@book.save`）がtrueのときはその後ろからelseの前までを、falseのときはelse以降endまでを実行します。

`@book.save`に成功するとtrueを返すので、`redirect_to @book, notice: 'Book was successfully created.'`が実行されます。redirect_toはリダイレクト（新たにリクエストを発行して画面遷移させる）指示で、ここではshowアクションへのリクエストが発生します。保存した本の詳細ページ（BooksControllerのshowアクション）を表示します。後ろのnotice部は画面に表示させる文を設定しています。

TODO: スクショ再作成置換

![リダイレクト後のshowアクション画面とnoticeの表示](assets/model/app_ss/redirect_to_show.png)

`@book.save`に失敗するとfalseを返すので、ifのelse節、`render :new`が実行されます。renderはコントローラの次の処理であるビューを指定します。ここでは`app/views/books/new.html.erb`がビューとして使われ、新規入力画面、つまり直前で入力していたページが表示されます。

ところで、saveメソッドが失敗するのはどんなときでしょうか？DBへの接続エラーなどのアクシデントで失敗することもありますが、モデルにある検証機能「バリデーション」を使って、想定外の入力に対して保存を失敗させることもあります。たとえば、数字を期待している郵便番号入力欄に、数字以外の文字が入力されるようなケースは、バリデーションを実装することで入力画面へ戻しユーザーに再入力を促すことができます。バリデーションについてはここでは説明しませんが、便利な機能なので [Rails Guides : Active Record バリデーション](http://railsguides.jp/active_record_validations.html) などの説明を参考にしてみてください。

## まとめ

### scaffoldで作られるmodel、migration

では、scaffoldで作られるmodel、migrationをまとめます。

scaffoldコマンドを実行すると、ファイルがつくられます。

![scaffoldコマンドがファイルを作る](assets/model/figures/summary_scaffold_make_files.png)

つづいてrails db:migrateコマンドを実行すると、DBがつくられます。

![rails db migrateコマンドがDBを作る](assets/model/figures/summary_rails_db_migrate.png)

できたモデルとDBをつかってアプリが動きます。

![モデルとDBでアプリは動く](assets/model/figures/summary_model_db.png)

### モデルの使い方

```ruby
book = Book.new(title: "RubyとRailsの学習ガイド",
                memo: "Rails関連技術地図とそれらの学習資料の紹介")
```

Book.newでBook Modelオブジェクトを作ります。モデル名は英語の単数形にするルールがあります。引数でtitle、memoといった各カラムのデータを渡せます。

```ruby
book.save
```

saveメソッドを呼ぶと保存できます。

```ruby
books = Book.all.to_a
```

Book.allでDBに保存されているBook Modelの全データを取得できます。Book.all.to_aを実行すると、ArrayにBookオブジェクトが詰まって返ってきます。

TODO

```ruby
book = Book.where(title: "RubyとRailsの学習ガイド").first
book.title #=> "RubyとRailsの学習ガイド"
book.memo #=> "Rails関連技術地図とそれらの学習資料の紹介"
```

whereメソッドを使うと検索ができます。タイトルが"RubyとRailsの学習ガイド"であるBookオブジェクトが返ります。検索で取れたBookオブジェクトは、titleメソッドでタイトルを、memoメソッドでメモをそれぞれ取得できます。

ポイントをまとめると以下のようになります。

- DBはデータの保存、読み込み、検索に特化したプログラム
- モデルはDBを便利に使うための道具。DBとモデルはセットで使われる
- マイグレーション（migration）ファイルはDBを作るための設計書
- rails db:migrateはマイグレーションファイルからDBを作るコマンド

## さらに学びたい場合は

モデルはとても多機能です。RailsGuidesにもたくさんの説明ページがあります。うまく使うことで便利な機能を簡単に作ることができるのです。

- [Rails Guides : Active Record の基礎](http://railsguides.jp/active_record_basics.html)
  - モデルに関する詳しい説明です。

- [Rails Guides : Active Record マイグレーション](http://railsguides.jp/active_record_migrations.html)
  - DBのマイグレーションに関する詳しい説明です。

- [Rails Guides : Active Record クエリインターフェイス](http://railsguides.jp/active_record_querying.html)
  - モデルの中で、検索に関する詳しい説明です。

- [Rails Guides : Active Record バリデーション](http://railsguides.jp/active_record_validations.html)
  - モデルには「バリデーション」と呼ばれる、便利な値のチェック機能がついています。実際のアプリを作る際によく使う機能なので、ぜひチャレンジしてみてください。

- [Rails Guides : Active Record の関連付け](http://railsguides.jp/association_basics.html)
  - 複数のモデルを結び付ける「関連付け」の機能は強力でアプリを作る際に大変便利です。ちょっととっつき難いですが、ぜひチャレンジしてみてください。

## 既存のDBテーブルにカラムを増やすには？

既存のDBテーブルにカラムを増やすにはどうすれば良いでしょうか？前に作ったmigrationファイルを編集してもうまくいきません。 各migrationファイルは1回だけ実行される仕組みなので、すでに存在しているmigrationファイルを変更しても、そのファイルは実行されないからです。そこで、新しいカラムを追加するには、新しいmigrationファイルを作ります。

rails gコマンドにmigrationを指定するとmigrationファイルだけを生成できます。たとえば、booksテーブルにstring型のauthorを加えるには以下のようにします（ファイル名中の"20160215230716"は実行するごとに異なります）。

```bash
rails g migration AddAuthorToBooks author:string
```

```console
$ rails g migration AddAuthorToBooks author:string
      invoke  active_record
      create    db/migrate/20191017231132_add_author_to_books.rb
```

rails g migrationコマンドの基本形は以下になります。

```bash
rails g migration Addカラム名Toテーブル名 カラム名:型名
```

作成されたmigrationファイルは以下のようになっています。

```
20191017231132_add_author_to_books.rb
```

```ruby
class AddAuthorToBooks < ActiveRecord::Migration[6.0]
  def change
    add_column :books, :author, :string
  end
end
```

生成されたmigrationファイルには、booksテーブルへauthorカラムをstring型で追加する指示が書かれています。

migrationファイルを作成したら、`rails db:migrate`コマンドでDBへ内容を反映します。

```bash
$ rails db:migrate
```

```console
== 20191017231132 AddAuthorToBooks: migrating =================================
-- add_column(:books, :author, :string)
   -> 0.0031s
== 20191017231132 AddAuthorToBooks: migrated (0.0033s) ========================
```

これで、DBのbooksテーブルへauthorカラムが追加されました。

ここまでの作業をまとめると、以下のようになります。

TODO: 新図をアレンジして置き換え

![booksテーブルにstring型のauthorを加えるmigration](assets/model/figures/migration_new_column_author.png)

ちなみに、Railsのgenerate機能は開発をアシストする機能なので、使わないで0から手でコードを書いても同様に動きます。rails gを使ってファイルを作っても、0から手でコードを書いても同じ結果になります。以下の図を参考にしてください。

TODO: 新図をアレンジして置き換え、本文に展開

![generateしても、0から書いても良い](assets/model/figures/migration_generate_or_write.png)

## 新しいモデルとmigrationを一緒に作るには？

rails gコマンドにmodelを指定するとmodelとmigrationを生成できます。

```ruby
rails g model book title:string memo:text
```

```console
db/migrate/20160216060032_create_books.rb
app/models/book.rb
```

## rails gコマンドまとめ

rails gコマンドの一覧をまとめます。

rails g migration: migration

```bash
$ rails g migration AddAuthorToBooks author:string
```

rails g model: model + migration

```bash
$ rails g model book title:string memo:text
```

rails g controller: routes + controller + view

```bash
$ rails g controller books index
```

rails g scaffold: model + migration + routes + controller + view

```bash
$ rails g scaffold book title:string memo:text
```

## 発展課題: scaffoldでつくったCRUDページを持つモデルへカラムを追加するには？

すでにあるbooksテーブルにstring型のauthorを加えて、ブラウザから入力できるようにしてみましょう。

### booksテーブルにstring型のauthorを加える

```bash
$ rails g migration AddAuthorToBooks author:string
```
```console
$ rails g migration AddAuthorToBooks author:string
      invoke  active_record
      create    db/migrate/20191017231132_add_author_to_books.rb
```

作成されたファイルは以下のようになっています。

`db/migrate/20191017231132_add_author_to_books.rb`

```ruby
class AddAuthorToBooks < ActiveRecord::Migration[6.0]
  def change
    add_column :books, :author, :string
  end
end
```

### migrationからDBを作る

```bash
$ rails db:migrate
```

```console
== 20191017231132 AddAuthorToBooks: migrating =================================
-- add_column(:books, :author, :string)
   -> 0.0031s
== 20191017231132 AddAuthorToBooks: migrated (0.0033s) ========================
```

### viewを修正

#### フォームパーシャル

`app/views/books/_form.html.erb`

```diff
<%= form_with(model: book, local: true) do |form| %>
...
  <div class="field">
    <%= form.label :title %>
    <%= form.text_field :title %>
  </div>

  <div class="field">
    <%= form.label :memo %>
    <%= form.text_area :memo %>
  </div>

+  <div class="field">
+    <%= form.label :author %>
+    <%= form.text_field :author %>
+  </div>

  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
```

#### 詳細表示画面

`app/views/books/show.html.erb`

```diff
<p id="notice"><%= notice %></p>

<p>
  <strong>Title:</strong>
  <%= @book.title %>
</p>

<p>
  <strong>Memo:</strong>
  <%= @book.memo %>
</p>

+<p>
+  <strong>Author:</strong>
+  <%= @book.author %>
+</p>

<%= link_to 'Edit', edit_book_path(@book) %> |
<%= link_to 'Back', books_path %>
```

#### 一覧表示画面

`app/views/books/index.html.erb`

```diff
<p id="notice"><%= notice %></p>

<h1>Books</h1>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Memo</th>
+      <th>Author</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @books.each do |book| %>
      <tr>
        <td><%= book.title %></td>
        <td><%= book.memo %></td>
+        <td><%= book.author %></td>
        <td><%= link_to 'Show', book %></td>
        <td><%= link_to 'Edit', edit_book_path(book) %></td>
        <td><%= link_to 'Destroy', book, method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New Book', new_book_path %>
```

### controllerを修正

StrongParametersにauthorを追加します。

`app/controllers/books_controller.rb`

```diff
class BooksController < ApplicationController
...
    # Never trust parameters from the scary internet, only allow the white list through.
    def book_params
-      params.require(:book).permit(:title, :memo)
+      params.require(:book).permit(:title, :memo, :author)
    end
end
```

### 動作確認

rails serverを起動して動作を確認してみましょう。

TODO: 新スクショ置き換え

![新規入力画面](assets/model/app_ss/add_author_new.png)

TODO: 新スクショ置き換え

![詳細画面](assets/model/app_ss/add_author_show.png)

TODO: 新スクショ置き換え

![一覧画面](assets/model/app_ss/add_author_index.png)

各画面にAuthor欄が追加されて、登録できるようになりました。
